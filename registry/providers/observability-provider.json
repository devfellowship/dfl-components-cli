{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "observability-provider",
  "type": "registry:component",
  "title": "ObservabilityProvider",
  "description": "Browser observability SDK that auto-initializes OpenTelemetry for React apps. Provides tracing, metrics, Web Vitals, fetch instrumentation, error boundaries, and React Query error reporting via a single provider wrapper.",
  "category": "Providers",
  "version": "1.0.0",
  "tags": [
    "observability",
    "opentelemetry",
    "tracing",
    "metrics",
    "web-vitals",
    "error-boundary",
    "provider"
  ],
  "dependencies": [
    "@opentelemetry/api",
    "@opentelemetry/sdk-trace-web",
    "@opentelemetry/exporter-trace-otlp-http",
    "@opentelemetry/sdk-metrics",
    "@opentelemetry/exporter-metrics-otlp-http",
    "@opentelemetry/resources",
    "@opentelemetry/semantic-conventions",
    "web-vitals"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "observability/lib/otel-init.ts",
      "type": "registry:component",
      "content": "import { Resource } from \"@opentelemetry/resources\";\nimport {\n  WebTracerProvider,\n  BatchSpanProcessor,\n} from \"@opentelemetry/sdk-trace-web\";\nimport { OTLPTraceExporter } from \"@opentelemetry/exporter-trace-otlp-http\";\nimport {\n  MeterProvider,\n  PeriodicExportingMetricReader,\n} from \"@opentelemetry/sdk-metrics\";\nimport { OTLPMetricExporter } from \"@opentelemetry/exporter-metrics-otlp-http\";\nimport { trace, metrics } from \"@opentelemetry/api\";\nimport { getStaticAttributes } from \"./resource-attributes\";\n\nexport interface OtelBrowserConfig {\n  serviceName: string;\n  serviceVersion: string;\n  collectorUrl: string;\n  apiKey?: string;\n}\n\nexport interface OtelProviders {\n  tracerProvider: WebTracerProvider;\n  meterProvider: MeterProvider;\n}\n\nexport function initOtelBrowser(config: OtelBrowserConfig): OtelProviders {\n  const { serviceName, serviceVersion, collectorUrl, apiKey } = config;\n\n  const headers: Record<string, string> = {};\n  if (apiKey) {\n    headers[\"x-api-key\"] = apiKey;\n  }\n\n  const staticAttributes = getStaticAttributes();\n\n  const resource = new Resource({\n    \"service.name\": serviceName,\n    \"service.version\": serviceVersion,\n    ...staticAttributes,\n  });\n\n  // --- Traces ---\n  const traceExporter = new OTLPTraceExporter({\n    url: `${collectorUrl}/v1/traces`,\n    headers,\n  });\n\n  const tracerProvider = new WebTracerProvider({\n    resource,\n    spanProcessors: [new BatchSpanProcessor(traceExporter)],\n  });\n\n  tracerProvider.register();\n\n  // --- Metrics ---\n  const metricExporter = new OTLPMetricExporter({\n    url: `${collectorUrl}/v1/metrics`,\n    headers,\n  });\n\n  const metricReader = new PeriodicExportingMetricReader({\n    exporter: metricExporter,\n    exportIntervalMillis: 60_000,\n  });\n\n  const meterProvider = new MeterProvider({\n    resource,\n    readers: [metricReader],\n  });\n\n  metrics.setGlobalMeterProvider(meterProvider);\n\n  // Store the collector URL globally so the fetch instrumentation can filter it\n  (globalThis as Record<string, unknown>).__otelCollectorUrl = collectorUrl;\n\n  return { tracerProvider, meterProvider };\n}\n\nexport function shutdownOtel(providers: OtelProviders): void {\n  const { tracerProvider, meterProvider } = providers;\n\n  trace.disable();\n  metrics.disable();\n\n  tracerProvider.shutdown().catch((err) => {\n    console.warn(\"[observability] tracer shutdown error:\", err);\n  });\n\n  meterProvider.shutdown().catch((err) => {\n    console.warn(\"[observability] meter shutdown error:\", err);\n  });\n}\n"
    },
    {
      "path": "observability/lib/resource-attributes.ts",
      "type": "registry:component",
      "content": "/**\n * Auto-collected resource attributes for browser observability.\n *\n * Static attributes are gathered once at init time.\n * Dynamic attributes change during the session (e.g. route, viewport).\n * User attributes are set after authentication completes.\n */\n\n// ---- Module-level mutable state for post-auth enrichment ----\nlet _userId: string | undefined;\nlet _userRole: string | undefined;\n\nexport function setUserId(id: string): void {\n  _userId = id;\n}\n\nexport function setUserRole(role: string): void {\n  _userRole = role;\n}\n\n// ---- Session ID (stable per tab session) ----\nfunction getSessionId(): string {\n  const key = \"__otel_session_id\";\n  let id = sessionStorage.getItem(key);\n  if (!id) {\n    id = crypto.randomUUID();\n    sessionStorage.setItem(key, id);\n  }\n  return id;\n}\n\n// ---- Browser detection (lightweight, no external lib) ----\ninterface BrowserInfo {\n  name: string;\n  version: string;\n}\n\nfunction detectBrowser(): BrowserInfo {\n  const ua = navigator.userAgent;\n\n  if (ua.includes(\"Firefox/\")) {\n    const match = ua.match(/Firefox\\/([\\d.]+)/);\n    return { name: \"Firefox\", version: match?.[1] ?? \"unknown\" };\n  }\n  if (ua.includes(\"Edg/\")) {\n    const match = ua.match(/Edg\\/([\\d.]+)/);\n    return { name: \"Edge\", version: match?.[1] ?? \"unknown\" };\n  }\n  if (ua.includes(\"Chrome/\") && !ua.includes(\"Edg/\")) {\n    const match = ua.match(/Chrome\\/([\\d.]+)/);\n    return { name: \"Chrome\", version: match?.[1] ?? \"unknown\" };\n  }\n  if (ua.includes(\"Safari/\") && !ua.includes(\"Chrome/\")) {\n    const match = ua.match(/Version\\/([\\d.]+)/);\n    return { name: \"Safari\", version: match?.[1] ?? \"unknown\" };\n  }\n\n  return { name: \"unknown\", version: \"unknown\" };\n}\n\n// ---- OS detection ----\nfunction detectOS(): string {\n  const ua = navigator.userAgent;\n  if (ua.includes(\"Win\")) return \"Windows\";\n  if (ua.includes(\"Mac\")) return \"macOS\";\n  if (ua.includes(\"Linux\")) return \"Linux\";\n  if (ua.includes(\"Android\")) return \"Android\";\n  if (/iPhone|iPad|iPod/.test(ua)) return \"iOS\";\n  return \"unknown\";\n}\n\n// ---- Device type via viewport heuristic ----\nfunction detectDeviceType(): string {\n  const width = window.innerWidth;\n  if (width < 768) return \"mobile\";\n  if (width < 1024) return \"tablet\";\n  return \"desktop\";\n}\n\n// ---- Connection info ----\nfunction getEffectiveConnectionType(): string | undefined {\n  const nav = navigator as Navigator & {\n    connection?: { effectiveType?: string };\n  };\n  return nav.connection?.effectiveType;\n}\n\n// ---- Public API ----\n\n/**\n * Attributes that are stable for the lifetime of the page.\n * Collected once during OTel SDK initialization.\n */\nexport function getStaticAttributes(): Record<string, string> {\n  const browser = detectBrowser();\n  const attrs: Record<string, string> = {\n    \"browser.name\": browser.name,\n    \"browser.version\": browser.version,\n    \"os.type\": detectOS(),\n    \"device.type\": detectDeviceType(),\n    \"session.id\": getSessionId(),\n  };\n\n  // Vite env-based app metadata\n  const appName = (import.meta as ImportMeta & { env: Record<string, string> })\n    .env?.VITE_APP_NAME;\n  const appVersion = (\n    import.meta as ImportMeta & { env: Record<string, string> }\n  ).env?.VITE_APP_VERSION;\n\n  if (appName) attrs[\"app.name\"] = appName;\n  if (appVersion) attrs[\"app.version\"] = appVersion;\n\n  return attrs;\n}\n\n/**\n * Attributes that may change between spans (viewport, route, user, connection).\n * Called per-span or at strategic points.\n */\nexport function getDynamicAttributes(): Record<string, string | number> {\n  const attrs: Record<string, string | number> = {\n    \"viewport.width\": window.innerWidth,\n    \"viewport.height\": window.innerHeight,\n  };\n\n  if (_userId) attrs[\"user.id\"] = _userId;\n  if (_userRole) attrs[\"user.role\"] = _userRole;\n\n  const connType = getEffectiveConnectionType();\n  if (connType) attrs[\"connection.effectiveType\"] = connType;\n\n  // page.route is typically set by the ObservabilityProvider via React Router\n  const route = (globalThis as Record<string, unknown>).__otelCurrentRoute;\n  if (typeof route === \"string\") attrs[\"page.route\"] = route;\n\n  return attrs;\n}\n"
    },
    {
      "path": "observability/lib/fetch-instrumentation.ts",
      "type": "registry:component",
      "content": "import { Tracer, SpanKind, SpanStatusCode } from \"@opentelemetry/api\";\nimport { getDynamicAttributes } from \"./resource-attributes\";\n\ntype NativeFetch = typeof globalThis.fetch;\n\nlet _originalFetch: NativeFetch | null = null;\n\n/**\n * Monkey-patches `window.fetch` to automatically create OTel spans for\n * every outgoing HTTP request.\n *\n * Collector URLs are filtered out to prevent infinite export loops.\n */\nexport function instrumentFetch(tracer: Tracer): void {\n  if (_originalFetch) {\n    // Already instrumented — avoid double-wrapping.\n    return;\n  }\n\n  _originalFetch = window.fetch.bind(window);\n\n  window.fetch = async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    const url =\n      input instanceof Request ? input.url : input instanceof URL ? input.href : input;\n    const method = init?.method ?? (input instanceof Request ? input.method : \"GET\");\n\n    // Filter out OTel collector traffic to avoid infinite loops.\n    const collectorUrl = (globalThis as Record<string, unknown>).__otelCollectorUrl;\n    if (typeof collectorUrl === \"string\" && url.startsWith(collectorUrl)) {\n      return _originalFetch!(input, init);\n    }\n\n    const dynamicAttrs = getDynamicAttributes();\n\n    return tracer.startActiveSpan(\n      `HTTP ${method.toUpperCase()}`,\n      {\n        kind: SpanKind.CLIENT,\n        attributes: {\n          \"http.method\": method.toUpperCase(),\n          \"http.url\": url,\n          ...dynamicAttrs,\n        },\n      },\n      async (span) => {\n        try {\n          const response = await _originalFetch!(input, init);\n\n          span.setAttribute(\"http.status_code\", response.status);\n\n          const contentLength = response.headers.get(\"content-length\");\n          if (contentLength) {\n            span.setAttribute(\n              \"http.response_content_length\",\n              parseInt(contentLength, 10),\n            );\n          }\n\n          if (response.status >= 400) {\n            span.setStatus({\n              code: SpanStatusCode.ERROR,\n              message: `HTTP ${response.status}`,\n            });\n          }\n\n          return response;\n        } catch (error) {\n          const message =\n            error instanceof Error ? error.message : \"Network request failed\";\n          span.setStatus({ code: SpanStatusCode.ERROR, message });\n          span.recordException(error instanceof Error ? error : new Error(message));\n          throw error;\n        } finally {\n          span.end();\n        }\n      },\n    );\n  };\n}\n\n/**\n * Restores the original `window.fetch`, removing instrumentation.\n */\nexport function uninstrumentFetch(): void {\n  if (_originalFetch) {\n    window.fetch = _originalFetch;\n    _originalFetch = null;\n  }\n}\n"
    },
    {
      "path": "observability/lib/track-event.ts",
      "type": "registry:component",
      "content": "import { trace, SpanStatusCode } from \"@opentelemetry/api\";\nimport { getDynamicAttributes } from \"./resource-attributes\";\n\n/**\n * Emit a custom observability event as an OTel span.\n *\n * Uses the global tracer registered by the ObservabilityProvider,\n * so it can be called from anywhere in the app without prop-drilling.\n *\n * @example\n * ```ts\n * trackEvent(\"button_click\", { \"button.id\": \"checkout\", \"page\": \"/cart\" });\n * ```\n */\nexport function trackEvent(\n  name: string,\n  attributes?: Record<string, string | number | boolean>,\n): void {\n  const tracer = trace.getTracer(\"@dfl/observability\");\n\n  tracer.startActiveSpan(name, (span) => {\n    const dynamicAttrs = getDynamicAttributes();\n\n    span.setAttribute(\"event.name\", name);\n\n    // Attach dynamic resource attributes (viewport, user, route, etc.)\n    for (const [key, value] of Object.entries(dynamicAttrs)) {\n      span.setAttribute(key, value);\n    }\n\n    // Attach caller-provided attributes\n    if (attributes) {\n      for (const [key, value] of Object.entries(attributes)) {\n        span.setAttribute(key, value);\n      }\n    }\n\n    span.setStatus({ code: SpanStatusCode.OK });\n    span.end();\n  });\n}\n"
    },
    {
      "path": "observability/hooks/useWebVitals.ts",
      "type": "registry:component",
      "content": "import { useEffect, useRef } from \"react\";\nimport { metrics } from \"@opentelemetry/api\";\nimport type { Metric } from \"web-vitals\";\n\n/**\n * Captures Core Web Vitals (LCP, FID, CLS, INP, TTFB) and reports them\n * as OTel histogram metrics via the global MeterProvider.\n *\n * Runs once on mount. The `web-vitals` callbacks fire at most once per\n * metric per page load, so no debouncing is needed.\n */\nexport function useWebVitals(): void {\n  const initialized = useRef(false);\n\n  useEffect(() => {\n    if (initialized.current) return;\n    initialized.current = true;\n\n    const meter = metrics.getMeter(\"web-vitals\");\n\n    const lcpHistogram = meter.createHistogram(\"web_vital.lcp\", {\n      description: \"Largest Contentful Paint (ms)\",\n      unit: \"ms\",\n    });\n    const fidHistogram = meter.createHistogram(\"web_vital.fid\", {\n      description: \"First Input Delay (ms)\",\n      unit: \"ms\",\n    });\n    const clsHistogram = meter.createHistogram(\"web_vital.cls\", {\n      description: \"Cumulative Layout Shift\",\n      unit: \"\",\n    });\n    const inpHistogram = meter.createHistogram(\"web_vital.inp\", {\n      description: \"Interaction to Next Paint (ms)\",\n      unit: \"ms\",\n    });\n    const ttfbHistogram = meter.createHistogram(\"web_vital.ttfb\", {\n      description: \"Time to First Byte (ms)\",\n      unit: \"ms\",\n    });\n\n    const report = (\n      histogram: ReturnType<typeof meter.createHistogram>,\n      metric: Metric,\n    ) => {\n      histogram.record(metric.value, {\n        \"metric.id\": metric.id,\n        \"metric.rating\": metric.rating,\n      });\n    };\n\n    // Dynamic import so tree-shaking can drop web-vitals entirely when unused.\n    import(\"web-vitals\").then(({ onLCP, onFID, onCLS, onINP, onTTFB }) => {\n      onLCP((m) => report(lcpHistogram, m));\n      onFID((m) => report(fidHistogram, m));\n      onCLS((m) => report(clsHistogram, m));\n      onINP((m) => report(inpHistogram, m));\n      onTTFB((m) => report(ttfbHistogram, m));\n    });\n  }, []);\n}\n"
    },
    {
      "path": "observability/hooks/useQueryErrorReporter.ts",
      "type": "registry:component",
      "content": "import { useEffect } from \"react\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { trace, SpanStatusCode } from \"@opentelemetry/api\";\nimport { getDynamicAttributes } from \"../lib/resource-attributes\";\n\n/**\n * Subscribes to the React Query cache and creates OTel error spans\n * whenever a query transitions to the `error` state.\n *\n * Relies on the global tracer registered by the ObservabilityProvider.\n */\nexport function useQueryErrorReporter(): void {\n  const queryClient = useQueryClient();\n\n  useEffect(() => {\n    const tracer = trace.getTracer(\"@dfl/observability\");\n\n    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {\n      if (event.type === \"updated\" && event.action.type === \"error\") {\n        const query = event.query;\n        const error = query.state.error;\n\n        tracer.startActiveSpan(\"react-query-error\", (span) => {\n          const dynamicAttrs = getDynamicAttributes();\n          for (const [key, value] of Object.entries(dynamicAttrs)) {\n            span.setAttribute(key, value);\n          }\n\n          span.setAttribute(\"query.key\", JSON.stringify(query.queryKey));\n          span.setAttribute(\n            \"error.message\",\n            error instanceof Error ? error.message : String(error),\n          );\n          span.setAttribute(\n            \"error.type\",\n            error instanceof Error ? error.constructor.name : typeof error,\n          );\n\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message:\n              error instanceof Error ? error.message : \"React Query error\",\n          });\n\n          if (error instanceof Error) {\n            span.recordException(error);\n          }\n\n          span.end();\n        });\n      }\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [queryClient]);\n}\n"
    },
    {
      "path": "observability/ErrorBoundary.tsx",
      "type": "registry:component",
      "content": "import React, { Component, ErrorInfo, ReactNode } from \"react\";\nimport { trace, SpanStatusCode } from \"@opentelemetry/api\";\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n}\n\n/**\n * React error boundary that reports uncaught component errors to OTel\n * as error spans before rendering a fallback UI.\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    const tracer = trace.getTracer(\"@dfl/observability\");\n\n    tracer.startActiveSpan(\"react-error-boundary\", (span) => {\n      span.setAttribute(\"error.message\", error.message);\n      span.setAttribute(\"error.stack\", error.stack ?? \"\");\n      span.setAttribute(\n        \"error.component_stack\",\n        errorInfo.componentStack ?? \"\",\n      );\n\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error.message,\n      });\n\n      span.recordException(error);\n      span.end();\n    });\n  }\n\n  private handleReload = (): void => {\n    window.location.reload();\n  };\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <div className=\"flex min-h-[200px] flex-col items-center justify-center gap-4 rounded-lg border border-red-200 bg-red-50 p-8 text-center dark:border-red-900 dark:bg-red-950\">\n          <h2 className=\"text-lg font-semibold text-red-800 dark:text-red-200\">\n            Something went wrong\n          </h2>\n          <p className=\"max-w-md text-sm text-red-600 dark:text-red-400\">\n            An unexpected error occurred. Please try reloading the page.\n          </p>\n          <button\n            onClick={this.handleReload}\n            className=\"rounded-md bg-red-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:bg-red-700 dark:hover:bg-red-600\"\n          >\n            Reload page\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n"
    },
    {
      "path": "observability/ObservabilityProvider.tsx",
      "type": "registry:component",
      "content": "import React, { useEffect, useRef, ReactNode } from \"react\";\nimport { trace, SpanStatusCode } from \"@opentelemetry/api\";\nimport {\n  initOtelBrowser,\n  shutdownOtel,\n  type OtelProviders,\n} from \"./lib/otel-init\";\nimport {\n  instrumentFetch,\n  uninstrumentFetch,\n} from \"./lib/fetch-instrumentation\";\nimport { getDynamicAttributes } from \"./lib/resource-attributes\";\nimport { useWebVitals } from \"./hooks/useWebVitals\";\nimport { useQueryErrorReporter } from \"./hooks/useQueryErrorReporter\";\nimport { ErrorBoundary } from \"./ErrorBoundary\";\n\nexport interface ObservabilityConfig {\n  /** Service name reported to the collector. Default: VITE_APP_NAME or \"unknown\" */\n  serviceName?: string;\n  /** Service version. Default: VITE_APP_VERSION or \"0.0.0\" */\n  serviceVersion?: string;\n  /** OTel collector base URL. Default: \"https://otel.devfellowship.com\" */\n  collectorUrl?: string;\n  /** API key sent as x-api-key header. Default: VITE_OTEL_API_KEY */\n  apiKey?: string;\n  /** Master kill-switch. Default: true in production (import.meta.env.PROD) */\n  enabled?: boolean;\n  /** Capture Core Web Vitals. Default: true */\n  enableWebVitals?: boolean;\n  /** Report React Query errors as spans. Default: true */\n  enableQueryTracking?: boolean;\n  /** Auto-trace all fetch() calls. Default: true */\n  enableFetchTracing?: boolean;\n}\n\ninterface ObservabilityProviderProps extends ObservabilityConfig {\n  children: ReactNode;\n}\n\n// ---- Internal active-instrumentation wrapper ----\n\nfunction ActiveInstrumentation({\n  enableWebVitals,\n  enableQueryTracking,\n  children,\n}: {\n  enableWebVitals: boolean;\n  enableQueryTracking: boolean;\n  children: ReactNode;\n}) {\n  if (enableWebVitals) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useWebVitals();\n  }\n\n  if (enableQueryTracking) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useQueryErrorReporter();\n  }\n\n  return <>{children}</>;\n}\n\n// ---- Main provider ----\n\nexport function ObservabilityProvider({\n  serviceName,\n  serviceVersion,\n  collectorUrl,\n  apiKey,\n  enabled,\n  enableWebVitals = true,\n  enableQueryTracking = true,\n  enableFetchTracing = true,\n  children,\n}: ObservabilityProviderProps) {\n  const env = (\n    import.meta as ImportMeta & { env: Record<string, string | boolean> }\n  ).env;\n\n  const isEnabled = enabled ?? (env?.PROD === true);\n\n  const providersRef = useRef<OtelProviders | null>(null);\n\n  const resolvedServiceName =\n    serviceName ?? (env?.VITE_APP_NAME as string) ?? \"unknown\";\n  const resolvedServiceVersion =\n    serviceVersion ?? (env?.VITE_APP_VERSION as string) ?? \"0.0.0\";\n  const resolvedCollectorUrl =\n    collectorUrl ?? \"https://otel.devfellowship.com\";\n  const resolvedApiKey = apiKey ?? (env?.VITE_OTEL_API_KEY as string);\n\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    // Initialize OTel SDK\n    const providers = initOtelBrowser({\n      serviceName: resolvedServiceName,\n      serviceVersion: resolvedServiceVersion,\n      collectorUrl: resolvedCollectorUrl,\n      apiKey: resolvedApiKey,\n    });\n    providersRef.current = providers;\n\n    // Fetch instrumentation\n    if (enableFetchTracing) {\n      const tracer = trace.getTracer(\"@dfl/observability\");\n      instrumentFetch(tracer);\n    }\n\n    // Global error handlers\n    const tracer = trace.getTracer(\"@dfl/observability\");\n\n    const handleWindowError = (event: ErrorEvent) => {\n      tracer.startActiveSpan(\"window.onerror\", (span) => {\n        const dynamicAttrs = getDynamicAttributes();\n        for (const [key, value] of Object.entries(dynamicAttrs)) {\n          span.setAttribute(key, value);\n        }\n\n        span.setAttribute(\"error.message\", event.message);\n        span.setAttribute(\"error.source\", event.filename ?? \"\");\n        span.setAttribute(\"error.lineno\", event.lineno ?? 0);\n        span.setAttribute(\"error.colno\", event.colno ?? 0);\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: event.message,\n        });\n\n        if (event.error instanceof Error) {\n          span.recordException(event.error);\n        }\n\n        span.end();\n      });\n    };\n\n    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n      tracer.startActiveSpan(\"unhandled-rejection\", (span) => {\n        const dynamicAttrs = getDynamicAttributes();\n        for (const [key, value] of Object.entries(dynamicAttrs)) {\n          span.setAttribute(key, value);\n        }\n\n        const reason = event.reason;\n        const message =\n          reason instanceof Error ? reason.message : String(reason);\n\n        span.setAttribute(\"error.message\", message);\n        span.setAttribute(\"error.type\", \"unhandled_promise_rejection\");\n\n        span.setStatus({ code: SpanStatusCode.ERROR, message });\n\n        if (reason instanceof Error) {\n          span.recordException(reason);\n        }\n\n        span.end();\n      });\n    };\n\n    window.addEventListener(\"error\", handleWindowError);\n    window.addEventListener(\"unhandledrejection\", handleUnhandledRejection);\n\n    return () => {\n      window.removeEventListener(\"error\", handleWindowError);\n      window.removeEventListener(\"unhandledrejection\", handleUnhandledRejection);\n\n      if (enableFetchTracing) {\n        uninstrumentFetch();\n      }\n\n      if (providersRef.current) {\n        shutdownOtel(providersRef.current);\n        providersRef.current = null;\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isEnabled]);\n\n  // No-op mode: just render children without any instrumentation\n  if (!isEnabled) {\n    return <>{children}</>;\n  }\n\n  return (\n    <ErrorBoundary>\n      <ActiveInstrumentation\n        enableWebVitals={enableWebVitals}\n        enableQueryTracking={enableQueryTracking}\n      >\n        {children}\n      </ActiveInstrumentation>\n    </ErrorBoundary>\n  );\n}\n"
    },
    {
      "path": "observability/index.ts",
      "type": "registry:component",
      "content": "// @dfl/observability — Browser observability SDK for React apps\n// Distributed via the dfl-components-cli registry.\n\nexport { ObservabilityProvider } from \"./ObservabilityProvider\";\nexport type { ObservabilityConfig } from \"./ObservabilityProvider\";\n\nexport { ErrorBoundary } from \"./ErrorBoundary\";\n\nexport { trackEvent } from \"./lib/track-event\";\n\nexport { setUserId, setUserRole } from \"./lib/resource-attributes\";\n\nexport { useWebVitals } from \"./hooks/useWebVitals\";\nexport { useQueryErrorReporter } from \"./hooks/useQueryErrorReporter\";\n"
    }
  ]
}
